<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Complete Web Server</title>
  <link href="../Styles/stylesheet.css" rel="stylesheet" type="text/css" />
  <script src="../toc.js" type="text/javascript">



  //<![CDATA[

   <!-- empty -->
  //]]>
  </script>
  <script type="text/javascript">




  /* <![CDATA[ */
    (function() {
        var s = document.createElement("script"), t = document.getElementsByTagName("script")[0];
        s.type = "text/javascript";
        s.async = true;
        s.src = "http://api.flattr.com/js/0.6/load.js?mode=auto";
        t.parentNode.insertBefore(s, t);
    })();
  /* ]]> */
  </script>
  <style type="text/css">
/*<![CDATA[*/

  body { counter-reset: chapter 10; }

  a.sgc-8 {display:none;}
  span.sgc-7 {color: black}
  span.sgc-6 {color: darkmagenta}
  span.sgc-5 {color: green}
  span.sgc-4 {color: firebrick}
  span.sgc-3 {color: blue}
  span.sgc-2 {color: DarkRed}
  span.sgc-1 {color: purple}
  /*]]>*/
  </style>
</head>

<body>
  <div class="chapter">
    <h1 id="heading_id_2">A Complete Web Server</h1>
  </div>

  <div class="preface">
    <p>This chapter is principally a lengthy illustration of the HTTP chapter, building a complete Web server in Go. It also shows how to use templates in order to use expressions in text files to insert variable values and to generate repeated sections.</p>
  </div>

  <div class="generate_from_h2" id="generated-toc"></div>

  <h2 id="heading_id_3">Introduction</h2>

  <p>I am learning Chinese. Rather, after many years of trying I am still <em>attempting</em> to learn Chinese. Of course, rather than buckling down and getting on with it, I have tried all sorts of technical aids. I tried DVDs, videos, flashcards and so on. Eventually I realised that there <em>wasn't a good computer program for Chinese flashcards</em>, and so in the interests of learning, I needed to build one.</p>

  <p>I had found a program in Python to do some of the task. But sad to say it wasn't well written and after a few attempts at turning it upside down and inside out I came to the conclusion that it was better to start from scratch. Of course, a Web solution would be far better than a standalone one, because then all the other people in my Chinese class could share it, as well as any other learners out there. And of course, the server would be written in Go.</p>

  <p>The flashcards server is running at <a href="cict.bhtafe.edu.au:8000">cict.bhtafe.edu.au:8000</a>. The front page consists of a list of flashcard sets currently available, how you want a set displayed (random card order, Chinese, English or random), whether to display a set, add to it, etc. I've spent too much time building it - somehow my Chinese hasn't progressed much while I was doing it... It probably won't be too exciting as a program if you don't want to learn Chinese, but let's get into the structure.</p>

  <h2 id="heading_id_4">Static pages</h2>

  <p>Some pages will just have static content. These can be managed by a <code>fileServer</code>. For simplicity I put all of the static HTML pages and CSS files in the <code>html</code> directory and all of the JavaScript files in the <code>jscript</code> directory. These are then delivered by the Go code</p>
  <pre>
  <code>
fileServer := http.FileServer("jscript", "/jscript/")
http.Handle("/jscript/", fileServer)

fileServer = http.FileServer("html", "/html/")
http.Handle("/html/", fileServer)
  </code>
</pre>

  <h2 id="heading_id_5">Templates</h2>

  <p>The list of flashcard sets is open ended, depending on the number of files in a directory. These should not be hardcoded into an HTML page, but the content should be generated as needed. This is an obvious candidate for templates.</p>

  <p>The list of files in a directory is generated as a list of strings. These can then be displayed in a table using the template</p>
  <pre>
<code>
&lt;table&gt;
  {{range .}}
  &lt;tr&gt;
    &lt;td&gt;
      {{.}}
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</code>
</pre>

  <h2 id="heading_id_6">The Chinese Dictionary</h2>

  <p>Chinese is a complex language (aren't they all :-( ). The written form is hieroglyphic, that is "pictograms" instead of using an alphabet. But this written form has evolved over time, and even recently split into two forms: "traditional" Chinese as used in Taiwan and Hong Kong, and "simplified" Chinese as used in mainland China. While most of the characters are the same, about 1,000 are different. Thus a Chinese dictionary will often have two written forms of the same character.</p>

  <p>Most Westerners like me can't understand these characters. So there is a "Latinised" form called Pinyin which writes the characters in a phonetic alphabet based on the Latin alphabet. It isn't quite the Latin alphabet, because Chinese is a tonal language, and the Pinyin form has to show the tones (much like acccents in French and other European languages). So a typical dictionary has to show four things: the traditional form, the simplified form, the Pinyin and the English. For example,</p>

  <table border="1">
    <tr>
      <th>Traditional</th>

      <th>Simplified</th>

      <th>Pinyin</th>

      <th>English</th>
    </tr>

    <tr>
      <td>好</td>

      <td>好</td>

      <td>hǎo</td>

      <td>good</td>
    </tr>
  </table>

  <p>But again there is a little complication. There is a free <a href="http://www.mandarintools.com/worddict.html">Chinese/English dictionary</a> and even better, you can download it as a UTF-8 file, which Go is well suited to handle. In this, the Chinese characters are written in Unicode but the Pinyin characters are not: although there are Unicode characters for letters such as 'ǎ', many dictionaries including this one use the Latin 'a' and place the tone at the end of the word. Here it is the third tone, so "hǎo" is written as "hao3". This makes it easier for those who only have US keyboards and no Unicode editor to still communicate in Pinyin.</p>

  <p>This data format mismatch is not a big deal: just that somewhere along the line, between the original text dictionary and the display in the browser, a data massage has to be performed. Go templates allow this to be done by defining a custom template, so I chose that route. Alternatives could have been to do this as the dictionary is read in, or in the Javascript to display the final characters.</p>

  <p>The code for the Pinyin formatter is given below. Please don't bother reading it unless you are <em>really</em> interested in knowing the rules for Pinyin formatting.</p>
  <pre><code><span class="sgc-7">
<span class="sgc-1">package</span> pinyin

<span class="sgc-1">import</span> (
        <span class="sgc-2">"io"</span>
        <span class="sgc-2">"strings"</span>
)

<span class="sgc-1">func</span> <span class="sgc-3">PinyinFormatter</span>(w io.<span class="sgc-3">Writer</span>, format string, value ...<span class="sgc-1">interface</span>{}) {
        line := value[0].(string)
        words := strings.<span class="sgc-3">Fields</span>(line)
        <span class="sgc-1">for</span> n, word := range words {
                <span class="sgc-4">// convert "u:" to "ü" if present
</span>         uColon := strings.<span class="sgc-3">Index</span>(word, <span class="sgc-2">"u:"</span>)
                <span class="sgc-1">if</span> uColon != -1 {
                        parts := strings.<span class="sgc-3">SplitN</span>(word, <span class="sgc-2">"u:"</span>, 2)
                        word = parts[0] + <span class="sgc-2">"ü"</span> + parts[1]
                }
                println(word)
                <span class="sgc-4">// get last character, will be the tone if present
</span>         chars := []rune(word)
                tone := chars[len(chars)-1]
                <span class="sgc-1">if</span> tone == '5' {
                        words[n] = string(chars[0 : len(chars)-1])
                        println(<span class="sgc-2">"lost accent on"</span>, words[n])
                        <span class="sgc-1">continue</span>
                }
                <span class="sgc-1">if</span> tone &lt; '1' || tone &gt; '4' {
                        <span class="sgc-1">continue</span>
                }
                words[n] = addAccent(word, <span class="sgc-5">int</span>(tone))
        }
        line = strings.<span class="sgc-3">Join</span>(words, ` `)
        w.<span class="sgc-3">Write</span>([]<span class="sgc-5">byte</span>(line))
}

<span class="sgc-1">var</span> (
        <span class="sgc-4">// maps 'a1' to '\u0101' etc
</span> aAccent = map[<span class="sgc-5">int</span>]rune{
                '1': '\u0101',
                '2': '\u00e1',
                '3': '\u01ce', <span class="sgc-4">// '\u0103',
</span>         '4': '\u00e0'}
        eAccent = map[<span class="sgc-5">int</span>]rune{
                '1': '\u0113',
                '2': '\u00e9',
                '3': '\u011b', <span class="sgc-4">// '\u0115',
</span>         '4': '\u00e8'}
        iAccent = map[<span class="sgc-5">int</span>]rune{
                '1': '\u012b',
                '2': '\u00ed',
                '3': '\u01d0', <span class="sgc-4">// '\u012d',
</span>         '4': '\u00ec'}
        oAccent = map[<span class="sgc-5">int</span>]rune{
                '1': '\u014d',
                '2': '\u00f3',
                '3': '\u01d2', <span class="sgc-4">// '\u014f',
</span>         '4': '\u00f2'}
        uAccent = map[<span class="sgc-5">int</span>]rune{
                '1': '\u016b',
                '2': '\u00fa',
                '3': '\u01d4', <span class="sgc-4">// '\u016d',
</span>         '4': '\u00f9'}
        ü<span class="sgc-3">Accent</span> = map[<span class="sgc-5">int</span>]rune{
                '1': 'ǖ',
                '2': 'ǘ',
                '3': 'ǚ',
                '4': 'ǜ'}
)

<span class="sgc-1">func</span> addAccent(word string, tone <span class="sgc-5">int</span>) string {
<span class="sgc-4">        /*
         * Based on "Where do the tone marks go?"
         * at http://www.pinyin.info/rules/where.html
         */
</span>
        n := strings.<span class="sgc-3">Index</span>(word, <span class="sgc-2">"a"</span>)
        <span class="sgc-1">if</span> n != -1 {
                aAcc := aAccent[tone]
                <span class="sgc-4">// replace 'a' with its tone version
</span>         word = word[0:n] + string(aAcc) + word[(n+1):len(word)-1]
        } <span class="sgc-1">else</span> {
                n := strings.<span class="sgc-3">Index</span>(word, <span class="sgc-2">"e"</span>)
                <span class="sgc-1">if</span> n != -1 {
                        eAcc := eAccent[tone]
                        word = word[0:n] + string(eAcc) +
                                word[(n+1):len(word)-1]
                } <span class="sgc-1">else</span> {
                        n = strings.<span class="sgc-3">Index</span>(word, <span class="sgc-2">"ou"</span>)
                        <span class="sgc-1">if</span> n != -1 {
                                oAcc := oAccent[tone]
                                word = word[0:n] + string(oAcc) + <span class="sgc-2">"u"</span> +
                                        word[(n+2):len(word)-1]
                        } <span class="sgc-1">else</span> {
                                chars := []rune(word)
                                length := len(chars)
                                <span class="sgc-4">// put tone onthe last vowel
</span>                 <span class="sgc-6">L</span>:
                                <span class="sgc-1">for</span> n, <span class="sgc-6">_</span> := range chars {
                                        m := length - n - 1
                                        <span class="sgc-1">switch</span> chars[m] {
                                        <span class="sgc-1">case</span> 'i':
                                                chars[m] = iAccent[tone]
                                                <span class="sgc-1">break</span> <span class="sgc-6">L</span>
                                        <span class="sgc-1">case</span> 'o':
                                                chars[m] = oAccent[tone]
                                                <span class="sgc-1">break</span> <span class="sgc-6">L</span>
                                        <span class="sgc-1">case</span> 'u':
                                                chars[m] = uAccent[tone]
                                                <span class="sgc-1">break</span> <span class="sgc-6">L</span>
                                        <span class="sgc-1">case</span> 'ü':
                                                chars[m] = ü<span class="sgc-3">Accent</span>[tone]
                                                <span class="sgc-1">break</span> <span class="sgc-6">L</span>
                                        <span class="sgc-1">default</span>:
                                        }
                                }
                                word = string(chars[0 : len(chars)-1])
                        }
                }
        }

        <span class="sgc-1">return</span> word
}
</span></code></pre>

  <p>How this is used is illustrated by the function <code>lookupWord</code>. This is called in response to an HTML Form request to find the English words in a dictionary.</p>
  <pre>
  <code>
func lookupWord(rw http.ResponseWriter, req *http.Request) {
        word := req.FormValue("word")
        words := d.LookupEnglish(word)

        pinyinMap := template.FormatterMap {"pinyin": pinyin.PinyinFormatter}
        t, err := template.ParseFile("html/DictionaryEntry.html", pinyinMap)
        if err != nil {
                http.Error(rw, err.String(), http.StatusInternalServerError)
                return
        }
        t.Execute(rw, words)
}
  </code>
</pre>

  <p>The HTML code is</p>
  <pre><code><span class="sgc-7">
&lt;html&gt;
  &lt;body&gt;
    &lt;table border=<span class="sgc-2">"1"</span>&gt;
      &lt;tr&gt;
        &lt;th&gt;<span class="sgc-3">Word</span>&lt;/th&gt;
        &lt;th&gt;<span class="sgc-3">Traditional</span>&lt;/th&gt;
        &lt;th&gt;<span class="sgc-3">Simplified</span>&lt;/th&gt;
        &lt;th&gt;<span class="sgc-3">Pinyin</span>&lt;/th&gt;
        &lt;th&gt;<span class="sgc-3">English</span>&lt;/th&gt;
      &lt;/tr&gt;
      {{with .<span class="sgc-3">Entries</span>}}
      {{range .}}
      {.repeated section <span class="sgc-3">Entries</span>}
      &lt;tr&gt;
        &lt;td&gt;{{.<span class="sgc-3">Word</span>}}&lt;/td&gt;
        &lt;td&gt;{{.<span class="sgc-3">Traditional</span>}}&lt;/td&gt; 
        &lt;td&gt;{{.<span class="sgc-3">Simplified</span>}}&lt;/td&gt;
        &lt;td&gt;{{.<span class="sgc-3">Pinyin</span>|pinyin}}&lt;/td&gt;
        &lt;td&gt;
          &lt;pre&gt;
            {.repeated section <span class="sgc-3">Translations</span>} 
            {@|html} 
            {.end}
          &lt;/pre&gt;
        &lt;/td&gt;
      &lt;/tr&gt;
      {.end} 
      {{end}}
      {{end}}
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</span></code></pre>

  <h3 id="heading_id_7">The Dictionary type</h3>

  <p>The text file containing the dictionary has lines of the form<br />
  <em>traditional simplified [pinyin] /translation/translation/.../</em><br />
  For example,<br />
  好 好 [hao3] /good/well/proper/good to/easy to/very/so/(suffix indicating completion or readiness)/</p>

  <p>We store each line as an <code>Entry</code> within the <code>Dictionary</code> package:</p>
  <pre>
  <code>
type Entry struct {
     Traditional string
     Simplified string
     Pinyin     string
     Translations []string
}
  </code>
</pre>

  <p>The dictionary itself is just an array of these entries:</p>
  <pre>
  <code>
type Dictionary struct {
      Entries []*Entry
}
  </code>
</pre>

  <p>Building the dictionary is easy enough. Just read each line and break the line into its various bits using simple string methods. Then add the line to the dictionary slice.</p>

  <p>Looking up entries in this dictionary is straightforward: just search through until we find the appropriate key. There are about 100,000 entries in this dictionary: brute force by a linear search is fast enough. If it were necessary, faster storage and search mechanisms could easily be used.</p>

  <p>The original dictionary grows by people on the Web adding in entries as they see fit. Consequently it isn't that well organised and contains repetitions and multiple entries. So looking up any word - either by Pinyin or by English - may return multiple matches. To cater for this, each lookup returns a "mini dictionary", just those lines in the full dictionary that match.</p>

  <p>The Dictionary code is</p>
  <pre><code><span class="sgc-7">
<span class="sgc-1">package</span> dictionary

<span class="sgc-1">import</span> (
        <span class="sgc-2">"bufio"</span>
        <span class="sgc-4">//"fmt"
</span> <span class="sgc-2">"os"</span>
        <span class="sgc-2">"strings"</span>
)

<span class="sgc-1">type</span> <span class="sgc-3">Entry</span> <span class="sgc-1">struct</span> {
        <span class="sgc-3">Traditional</span>  string
        <span class="sgc-3">Simplified</span>   string
        <span class="sgc-3">Pinyin</span>       string
        <span class="sgc-3">Translations</span> []string
}

<span class="sgc-1">func</span> (de <span class="sgc-3">Entry</span>) <span class="sgc-3">String</span>() string {
        str := de.<span class="sgc-3">Traditional</span> + ` ` + de.<span class="sgc-3">Simplified</span> + ` ` + de.<span class="sgc-3">Pinyin</span>
        <span class="sgc-1">for</span> <span class="sgc-6">_</span>, t := range de.<span class="sgc-3">Translations</span> {
                str = str + <span class="sgc-2">"\n    "</span> + t
        }
        <span class="sgc-1">return</span> str
}

<span class="sgc-1">type</span> <span class="sgc-3">Dictionary</span> <span class="sgc-1">struct</span> {
        <span class="sgc-3">Entries</span> []*<span class="sgc-3">Entry</span>
}

<span class="sgc-1">func</span> (d *<span class="sgc-3">Dictionary</span>) <span class="sgc-3">String</span>() string {
        str := <span class="sgc-2">""</span>
        <span class="sgc-1">for</span> n := 0; n &lt; len(d.<span class="sgc-3">Entries</span>); n++ {
                de := d.<span class="sgc-3">Entries</span>[n]
                str += de.<span class="sgc-3">String</span>() + <span class="sgc-2">"\n"</span>
        }
        <span class="sgc-1">return</span> str
}

<span class="sgc-1">func</span> (d *<span class="sgc-3">Dictionary</span>) <span class="sgc-3">LookupPinyin</span>(py string) *<span class="sgc-3">Dictionary</span> {
        newD := <span class="sgc-1">new</span>(<span class="sgc-3">Dictionary</span>)
        v := make([]*<span class="sgc-3">Entry</span>, 0, 100)
        <span class="sgc-1">for</span> n := 0; n &lt; len(d.<span class="sgc-3">Entries</span>); n++ {
                de := d.<span class="sgc-3">Entries</span>[n]
                <span class="sgc-1">if</span> de.<span class="sgc-3">Pinyin</span> == py {
                        v = append(v, de)
                }
        }
        newD.<span class="sgc-3">Entries</span> = v
        <span class="sgc-1">return</span> newD
}

<span class="sgc-1">func</span> (d *<span class="sgc-3">Dictionary</span>) <span class="sgc-3">LookupEnglish</span>(eng string) *<span class="sgc-3">Dictionary</span> {
        newD := <span class="sgc-1">new</span>(<span class="sgc-3">Dictionary</span>)
        v := make([]*<span class="sgc-3">Entry</span>, 0, 100)
        <span class="sgc-1">for</span> n := 0; n &lt; len(d.<span class="sgc-3">Entries</span>); n++ {
                de := d.<span class="sgc-3">Entries</span>[n]
                <span class="sgc-1">for</span> <span class="sgc-6">_</span>, e := range de.<span class="sgc-3">Translations</span> {
                        <span class="sgc-1">if</span> e == eng {
                                v = append(v, de)
                        }
                }
        }
        newD.<span class="sgc-3">Entries</span> = v
        <span class="sgc-1">return</span> newD
}

<span class="sgc-1">func</span> (d *<span class="sgc-3">Dictionary</span>) <span class="sgc-3">LookupSimplified</span>(simp string) *<span class="sgc-3">Dictionary</span> {
        newD := <span class="sgc-1">new</span>(<span class="sgc-3">Dictionary</span>)
        v := make([]*<span class="sgc-3">Entry</span>, 0, 100)

        <span class="sgc-1">for</span> n := 0; n &lt; len(d.<span class="sgc-3">Entries</span>); n++ {
                de := d.<span class="sgc-3">Entries</span>[n]
                <span class="sgc-1">if</span> de.<span class="sgc-3">Simplified</span> == simp {
                        v = append(v, de)
                }
        }
        newD.<span class="sgc-3">Entries</span> = v
        <span class="sgc-1">return</span> newD
}

<span class="sgc-1">func</span> (d *<span class="sgc-3">Dictionary</span>) <span class="sgc-3">Load</span>(path string) {

        f, err := os.<span class="sgc-3">Open</span>(path)
        r := bufio.<span class="sgc-3">NewReader</span>(f)
        <span class="sgc-1">if</span> err != nil {
                println(err.<span class="sgc-3">Error</span>())
                os.<span class="sgc-3">Exit</span>(1)
        }

        v := make([]*<span class="sgc-3">Entry</span>, 0, 100000)
        numEntries := 0
        <span class="sgc-1">for</span> {
                line, err := r.<span class="sgc-3">ReadString</span>('\n')
                <span class="sgc-1">if</span> err != nil {
                        <span class="sgc-1">break</span>
                }
                <span class="sgc-1">if</span> line[0] == '#' {
                        <span class="sgc-1">continue</span>
                }
                <span class="sgc-4">// fmt.Println(line)
</span>         trad, simp, pinyin, translations := parseDictEntry(line)

                de := <span class="sgc-3">Entry</span>{
                        <span class="sgc-3">Traditional</span>:  trad,
                        <span class="sgc-3">Simplified</span>:   simp,
                        <span class="sgc-3">Pinyin</span>:       pinyin,
                        <span class="sgc-3">Translations</span>: translations}

                v = append(v, &amp;de)
                numEntries++
        }
        <span class="sgc-4">// fmt.Printf("Num entries %d\n", numEntries)
</span> d.<span class="sgc-3">Entries</span> = v
}

<span class="sgc-1">func</span> parseDictEntry(line string) (string, string, string, []string) {
        <span class="sgc-4">// format is
</span> <span class="sgc-4">//    trad simp [pinyin] /trans/trans/.../
</span> tradEnd := strings.<span class="sgc-3">Index</span>(line, <span class="sgc-2">" "</span>)
        trad := line[0:tradEnd]
        line = strings.<span class="sgc-3">TrimSpace</span>(line[tradEnd:])

        simpEnd := strings.<span class="sgc-3">Index</span>(line, <span class="sgc-2">" "</span>)
        simp := line[0:simpEnd]
        line = strings.<span class="sgc-3">TrimSpace</span>(line[simpEnd:])

        pinyinEnd := strings.<span class="sgc-3">Index</span>(line, <span class="sgc-2">"]"</span>)
        pinyin := line[1:pinyinEnd]
        line = strings.<span class="sgc-3">TrimSpace</span>(line[pinyinEnd+1:])

        translations := strings.<span class="sgc-3">Split</span>(line, <span class="sgc-2">"/"</span>)
        <span class="sgc-4">// includes empty at start and end, so
</span> translations = translations[1 : len(translations)-1]

        <span class="sgc-1">return</span> trad, simp, pinyin, translations
}
</span></code></pre>

  <h2 id="heading_id_8">Flash cards</h2>

  <p>Each individual flash card is of the type <code>Flashcard</code></p>
  <pre>
<code>
type FlashCard struct {
        Simplified string
        English    string
        Dictionary *dictionary.Dictionary
}
</code>
</pre>

  <p>At present we only store the simplified character and the english translation for that character. We also have a <code>Dictionary</code> which will contain only one entry for the entry we will have chosen somewhere.</p>

  <p>A set of flash cards is defined by the type</p>
  <pre>
<code>
type FlashCards struct {
        Name      string
        CardOrder string
        ShowHalf  string
        Cards     []*FlashCard
}
</code>
</pre>

  <p>where the <code>CardOrder</code> will be "random" or "sequential" and the <code>ShowHalf</code> will be "RANDOM_HALF" or "ENGLISH_HALF" or "CHINESE_HALF" to determine which half of a new card is shown first.</p>

  <p>The code for flash cards has nothing novel in it. We get data from the client browser and use JSON to create an object from the form data, and store the set of flashcards as a JSON string.</p>

  <h2 id="heading_id_9">The Complete Server</h2>

  <p>The complete server is</p>
  <pre><code><span class="sgc-7">
<span class="sgc-4">/* Server
 */
</span>
<span class="sgc-1">package</span> main

<span class="sgc-1">import</span> (
        <span class="sgc-2">"fmt"</span>
        <span class="sgc-2">"io/ioutil"</span>
        <span class="sgc-2">"net/http"</span>
        <span class="sgc-2">"os"</span>
        <span class="sgc-2">"regexp"</span>
        <span class="sgc-2">"text/template"</span>
)

<span class="sgc-1">import</span> (
        <span class="sgc-2">"dictionary"</span>
        <span class="sgc-2">"flashcards"</span>
        <span class="sgc-2">"templatefuncs"</span>
)

<span class="sgc-1">var</span> d *dictionary.<span class="sgc-3">Dictionary</span>

<span class="sgc-1">func</span> main() {
        <span class="sgc-1">if</span> len(os.<span class="sgc-3">Args</span>) != 2 {
                fmt.<span class="sgc-3">Fprint</span>(os.<span class="sgc-3">Stderr</span>, <span class="sgc-2">"Usage: "</span>, os.<span class="sgc-3">Args</span>[0], <span class="sgc-2">":port\n"</span>)
                os.<span class="sgc-3">Exit</span>(1)
        }
        port := os.<span class="sgc-3">Args</span>[1]

        <span class="sgc-4">// dictionaryPath := "/var/www/go/chinese/cedict_ts.u8"
</span> dictionaryPath := <span class="sgc-2">"cedict_ts.u8"</span>
        d = <span class="sgc-1">new</span>(dictionary.<span class="sgc-3">Dictionary</span>)
        d.<span class="sgc-3">Load</span>(dictionaryPath)
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Loaded dict"</span>, len(d.<span class="sgc-3">Entries</span>))

        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/"</span>, listFlashCards)
        <span class="sgc-4">//fileServer := http.FileServer("/var/www/go/chinese/jscript", "/jscript/")     
</span> fileServer := http.<span class="sgc-3">StripPrefix</span>(<span class="sgc-2">"/jscript/"</span>, http.<span class="sgc-3">FileServer</span>(http.<span class="sgc-3">Dir</span>(<span class="sgc-2">"jscript"</span>)))
        http.<span class="sgc-3">Handle</span>(<span class="sgc-2">"/jscript/"</span>, fileServer)
        <span class="sgc-4">// fileServer = http.FileServer("/var/www/go/chinese/html", "/html/")
</span> fileServer = http.<span class="sgc-3">StripPrefix</span>(<span class="sgc-2">"/html/"</span>, http.<span class="sgc-3">FileServer</span>(http.<span class="sgc-3">Dir</span>(<span class="sgc-2">"html"</span>)))
        http.<span class="sgc-3">Handle</span>(<span class="sgc-2">"/html/"</span>, fileServer)

        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/wordlook"</span>, lookupWord)
        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/flashcards.html"</span>, listFlashCards)
        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/flashcardSets"</span>, manageFlashCards)
        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/searchWord"</span>, searchWord)
        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/addWord"</span>, addWord)
        http.<span class="sgc-3">HandleFunc</span>(<span class="sgc-2">"/newFlashCardSet"</span>, newFlashCardSet)

        <span class="sgc-4">// deliver requests to the handlers
</span> err := http.<span class="sgc-3">ListenAndServe</span>(port, nil)
        checkError(err)
        <span class="sgc-4">// That's it!
</span>}

<span class="sgc-1">func</span> indexPage(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {
        index, <span class="sgc-6">_</span> := ioutil.<span class="sgc-3">ReadFile</span>(<span class="sgc-2">"html/index.html"</span>)
        rw.<span class="sgc-3">Write</span>([]<span class="sgc-5">byte</span>(index))
}

<span class="sgc-1">func</span> lookupWord(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {
        word := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"word"</span>)
        words := d.<span class="sgc-3">LookupEnglish</span>(word)

        <span class="sgc-4">//t := template.New("PinyinTemplate")
</span> t := template.<span class="sgc-3">New</span>(<span class="sgc-2">"DictionaryEntry.html"</span>)
        t = t.<span class="sgc-3">Funcs</span>(template.<span class="sgc-3">FuncMap</span>{<span class="sgc-2">"pinyin"</span>: templatefuncs.<span class="sgc-3">PinyinFormatter</span>})
        t, err := t.<span class="sgc-3">ParseFiles</span>(<span class="sgc-2">"html/DictionaryEntry.html"</span>)
        <span class="sgc-1">if</span> err != nil {
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        t.<span class="sgc-3">Execute</span>(rw, words)
}

<span class="sgc-1">type</span> <span class="sgc-3">DictPlus</span> <span class="sgc-1">struct</span> {
        *dictionary.<span class="sgc-3">Dictionary</span>
        <span class="sgc-3">Word</span>     string
        <span class="sgc-3">CardName</span> string
}

<span class="sgc-1">func</span> searchWord(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {
        word := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"word"</span>)
        searchType := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"searchtype"</span>)
        cardName := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"cardname"</span>)

        <span class="sgc-1">var</span> words *dictionary.<span class="sgc-3">Dictionary</span>
        <span class="sgc-1">var</span> dp []<span class="sgc-3">DictPlus</span>
        <span class="sgc-1">if</span> searchType == <span class="sgc-2">"english"</span> {
                words = d.<span class="sgc-3">LookupEnglish</span>(word)
                d1 := <span class="sgc-3">DictPlus</span>{<span class="sgc-3">Dictionary</span>: words, <span class="sgc-3">Word</span>: word, <span class="sgc-3">CardName</span>: cardName}
                dp = make([]<span class="sgc-3">DictPlus</span>, 1)
                dp[0] = d1
        } <span class="sgc-1">else</span> {
                words = d.<span class="sgc-3">LookupPinyin</span>(word)
                numTrans := 0
                <span class="sgc-1">for</span> <span class="sgc-6">_</span>, entry := range words.<span class="sgc-3">Entries</span> {
                        numTrans += len(entry.<span class="sgc-3">Translations</span>)
                }
                dp = make([]<span class="sgc-3">DictPlus</span>, numTrans)
                idx := 0
                <span class="sgc-1">for</span> <span class="sgc-6">_</span>, entry := range words.<span class="sgc-3">Entries</span> {
                        <span class="sgc-1">for</span> <span class="sgc-6">_</span>, trans := range entry.<span class="sgc-3">Translations</span> {
                                dict := <span class="sgc-1">new</span>(dictionary.<span class="sgc-3">Dictionary</span>)
                                dict.<span class="sgc-3">Entries</span> = make([]*dictionary.<span class="sgc-3">Entry</span>, 1)
                                dict.<span class="sgc-3">Entries</span>[0] = entry
                                dp[idx] = <span class="sgc-3">DictPlus</span>{
                                        <span class="sgc-3">Dictionary</span>: dict,
                                        <span class="sgc-3">Word</span>:       trans,
                                        <span class="sgc-3">CardName</span>:   cardName}
                                idx++
                        }
                }
        }

        <span class="sgc-4">//t := template.New("PinyinTemplate")
</span> t := template.<span class="sgc-3">New</span>(<span class="sgc-2">"ChooseDictionaryEntry.html"</span>)
        t = t.<span class="sgc-3">Funcs</span>(template.<span class="sgc-3">FuncMap</span>{<span class="sgc-2">"pinyin"</span>: templatefuncs.<span class="sgc-3">PinyinFormatter</span>})
        t, err := t.<span class="sgc-3">ParseFiles</span>(<span class="sgc-2">"html/ChooseDictionaryEntry.html"</span>)
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        t.<span class="sgc-3">Execute</span>(rw, dp)
}

<span class="sgc-1">func</span> newFlashCardSet(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {
        defer http.<span class="sgc-3">Redirect</span>(rw, req, <span class="sgc-2">"http:/flashcards.html"</span>, 200)

        newSet := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"NewFlashcard"</span>)
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"New cards"</span>, newSet)
        <span class="sgc-4">// check against nasties:
</span> b, err := regexp.<span class="sgc-3">Match</span>(<span class="sgc-2">"[/$~]"</span>, []<span class="sgc-5">byte</span>(newSet))
        <span class="sgc-1">if</span> err != nil {
                <span class="sgc-1">return</span>
        }
        <span class="sgc-1">if</span> b {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"No good string"</span>)
                <span class="sgc-1">return</span>
        }

        flashcards.<span class="sgc-3">NewFlashCardSet</span>(newSet)
        <span class="sgc-1">return</span>
}

<span class="sgc-1">func</span> addWord(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {
        url := req.<span class="sgc-3">URL</span>
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"url"</span>, url.<span class="sgc-3">String</span>())
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"query"</span>, url.<span class="sgc-3">RawQuery</span>)

        word := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"word"</span>)
        cardName := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"cardname"</span>)
        simplified := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"simplified"</span>)
        pinyin := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"pinyin"</span>)
        traditional := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"traditional"</span>)
        translations := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"translations"</span>)

        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"word is "</span>, word, <span class="sgc-2">" card is "</span>, cardName,
                <span class="sgc-2">" simplified is "</span>, simplified, <span class="sgc-2">" pinyin is "</span>, pinyin,
                <span class="sgc-2">" trad is "</span>, traditional, <span class="sgc-2">" trans is "</span>, translations)
        flashcards.<span class="sgc-3">AddFlashEntry</span>(cardName, word, pinyin, simplified,
                traditional, translations)
        <span class="sgc-4">// add another card?
</span> addFlashCards(rw, cardName)
}

<span class="sgc-1">func</span> listFlashCards(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {

        flashCardsNames := flashcards.<span class="sgc-3">ListFlashCardsNames</span>()
        t, err := template.<span class="sgc-3">ParseFiles</span>(<span class="sgc-2">"html/ListFlashcards.html"</span>)
        <span class="sgc-1">if</span> err != nil {
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        t.<span class="sgc-3">Execute</span>(rw, flashCardsNames)
}

<span class="sgc-4">/* 
 * Called from ListFlashcards.html on form submission
 */
</span><span class="sgc-1">func</span> manageFlashCards(rw http.<span class="sgc-3">ResponseWriter</span>, req *http.<span class="sgc-3">Request</span>) {

        set := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"flashcardSets"</span>)
        order := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"order"</span>)
        action := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"submit"</span>)
        half := req.<span class="sgc-3">FormValue</span>(<span class="sgc-2">"half"</span>)
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"set chosen is"</span>, set)
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"order is"</span>, order)
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"action is"</span>, action)

        cardname := <span class="sgc-2">"flashcardSets/"</span> + set

        <span class="sgc-4">//components := strings.Split(req.URL.Path[1:], "/", -1)
</span> <span class="sgc-4">//cardname := components[1]
</span> <span class="sgc-4">//action := components[2]
</span> fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"cardname"</span>, cardname, <span class="sgc-2">"action"</span>, action)
        <span class="sgc-1">if</span> action == <span class="sgc-2">"Show cards in set"</span> {
                showFlashCards(rw, cardname, order, half)
        } <span class="sgc-1">else</span> <span class="sgc-1">if</span> action == <span class="sgc-2">"List words in set"</span> {
                listWords(rw, cardname)
        } <span class="sgc-1">else</span> <span class="sgc-1">if</span> action == <span class="sgc-2">"Add cards to set"</span> {
                addFlashCards(rw, set)
        }
}

<span class="sgc-1">func</span> showFlashCards(rw http.<span class="sgc-3">ResponseWriter</span>, cardname, order, half string) {
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Loading card name"</span>, cardname)
        cards := <span class="sgc-1">new</span>(flashcards.<span class="sgc-3">FlashCards</span>)
        <span class="sgc-4">//cards.Load(cardname, d)
</span> <span class="sgc-4">//flashcards.SaveJSON(cardname + ".json", cards)
</span> flashcards.<span class="sgc-3">LoadJSON</span>(cardname, &amp;cards)
        <span class="sgc-1">if</span> order == <span class="sgc-2">"Sequential"</span> {
                cards.<span class="sgc-3">CardOrder</span> = <span class="sgc-2">"SEQUENTIAL"</span>
        } <span class="sgc-1">else</span> {
                cards.<span class="sgc-3">CardOrder</span> = <span class="sgc-2">"RANDOM"</span>
        }
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"half is"</span>, half)
        <span class="sgc-1">if</span> half == <span class="sgc-2">"Random"</span> {
                cards.<span class="sgc-3">ShowHalf</span> = <span class="sgc-2">"RANDOM_HALF"</span>
        } <span class="sgc-1">else</span> <span class="sgc-1">if</span> half == <span class="sgc-2">"English"</span> {
                cards.<span class="sgc-3">ShowHalf</span> = <span class="sgc-2">"ENGLISH_HALF"</span>
        } <span class="sgc-1">else</span> {
                cards.<span class="sgc-3">ShowHalf</span> = <span class="sgc-2">"CHINESE_HALF"</span>
        }
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"loaded cards"</span>, len(cards.<span class="sgc-3">Cards</span>))
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Card name"</span>, cards.<span class="sgc-3">Name</span>)

        <span class="sgc-4">//t := template.New("PinyinTemplate")
</span> t := template.<span class="sgc-3">New</span>(<span class="sgc-2">"ShowFlashcards.html"</span>)
        t = t.<span class="sgc-3">Funcs</span>(template.<span class="sgc-3">FuncMap</span>{<span class="sgc-2">"pinyin"</span>: templatefuncs.<span class="sgc-3">PinyinFormatter</span>})
        t, err := t.<span class="sgc-3">ParseFiles</span>(<span class="sgc-2">"html/ShowFlashcards.html"</span>)
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        err = t.<span class="sgc-3">Execute</span>(rw, cards)
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Execute error "</span> + err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
}

<span class="sgc-1">func</span> listWords(rw http.<span class="sgc-3">ResponseWriter</span>, cardname string) {
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Loading card name"</span>, cardname)
        cards := <span class="sgc-1">new</span>(flashcards.<span class="sgc-3">FlashCards</span>)
        <span class="sgc-4">//cards.Load(cardname, d)
</span> flashcards.<span class="sgc-3">LoadJSON</span>(cardname, cards)
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"loaded cards"</span>, len(cards.<span class="sgc-3">Cards</span>))
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Card name"</span>, cards.<span class="sgc-3">Name</span>)

        <span class="sgc-4">//t := template.New("PinyinTemplate")
</span> t := template.<span class="sgc-3">New</span>(<span class="sgc-2">"ListWords.html"</span>)
        <span class="sgc-1">if</span> t.<span class="sgc-3">Tree</span> == nil || t.<span class="sgc-3">Root</span> == nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"New t is an incomplete or empty template"</span>)
        }
        t = t.<span class="sgc-3">Funcs</span>(template.<span class="sgc-3">FuncMap</span>{<span class="sgc-2">"pinyin"</span>: templatefuncs.<span class="sgc-3">PinyinFormatter</span>})
        t, err := t.<span class="sgc-3">ParseFiles</span>(<span class="sgc-2">"html/ListWords.html"</span>)
        <span class="sgc-1">if</span> t.<span class="sgc-3">Tree</span> == nil || t.<span class="sgc-3">Root</span> == nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Parsed t is an incomplete or empty template"</span>)
        }

        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Parse error "</span> + err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        err = t.<span class="sgc-3">Execute</span>(rw, cards)
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Execute error "</span> + err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"No error "</span>)
}

<span class="sgc-1">func</span> addFlashCards(rw http.<span class="sgc-3">ResponseWriter</span>, cardname string) {
        t, err := template.<span class="sgc-3">ParseFiles</span>(<span class="sgc-2">"html/AddWordToSet.html"</span>)
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Parse error "</span> + err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }
        cards := flashcards.<span class="sgc-3">GetFlashCardsByName</span>(cardname, d)
        t.<span class="sgc-3">Execute</span>(rw, cards)
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Execute error "</span> + err.<span class="sgc-3">Error</span>())
                http.<span class="sgc-3">Error</span>(rw, err.<span class="sgc-3">Error</span>(), http.<span class="sgc-3">StatusInternalServerError</span>)
                <span class="sgc-1">return</span>
        }

}

<span class="sgc-1">func</span> checkError(err error) {
        <span class="sgc-1">if</span> err != nil {
                fmt.<span class="sgc-3">Println</span>(<span class="sgc-2">"Fatal error "</span>, err.<span class="sgc-3">Error</span>())
                os.<span class="sgc-3">Exit</span>(1)
        }
}
</span></code></pre>

  <h2 id="heading_id_10">Other Bits: JavaScript and CSS</h2>

  <p>On request, a set of flashcards will be loaded into the browser. A much abbreviated set is shown below. The display of these cards is controlled by JavaScript and CSS files. These aren't relevant to the Go server so are omitted. Those interested can download the code.</p>
  <pre><code><span class="sgc-7">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;
      <span class="sgc-3">Flashcards</span> <span class="sgc-1">for</span> <span class="sgc-3">Common</span> <span class="sgc-3">Words</span>
    &lt;/title&gt;

    &lt;link <span class="sgc-1">type</span>=<span class="sgc-2">"text/css"</span> rel=<span class="sgc-2">"stylesheet"</span> 
          href=<span class="sgc-2">"/html/CardStylesheet.css"</span>&gt;
    &lt;/link&gt;

    &lt;script <span class="sgc-1">type</span>=<span class="sgc-2">"text/javascript"</span> 
            language=<span class="sgc-2">"JavaScript1.2"</span> src=<span class="sgc-2">"/jscript/jquery.js"</span>&gt;
      &lt;!-- empty --&gt;
    &lt;/script&gt;

    &lt;script <span class="sgc-1">type</span>=<span class="sgc-2">"text/javascript"</span> 
            language=<span class="sgc-2">"JavaScript1.2"</span> src=<span class="sgc-2">"/jscript/slideviewer.js"</span>&gt;
      &lt;!-- empty --&gt;
    &lt;/script&gt;

    &lt;script <span class="sgc-1">type</span>=<span class="sgc-2">"text/javascript"</span> 
            language=<span class="sgc-2">"JavaScript1.2"</span>&gt;
      cardOrder = <span class="sgc-3">RANDOM</span>;
      showHalfCard = <span class="sgc-3">RANDOM_HALF</span>;
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body onload=<span class="sgc-2">"showSlides();"</span>&gt; 
    &lt;h1&gt; 
      <span class="sgc-3">Flashcards</span> <span class="sgc-1">for</span> <span class="sgc-3">Common</span> <span class="sgc-3">Words</span>
    &lt;/h1&gt;
    &lt;p&gt;
        &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"card"</span>&gt;

          &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"english"</span>&gt;
            &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
              hello
            &lt;/div&gt;
          &lt;/div&gt;

              &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"pinyin"</span>&gt;
                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  nǐ hǎo
                &lt;/div&gt;

              &lt;/div&gt;
              
              &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"traditional"</span>&gt;
                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  你好
                &lt;/div&gt;
              &lt;/div&gt;
              
              &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"simplified"</span>&gt;
                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  你好
                &lt;/div&gt;

              &lt;/div&gt;

              &lt;div <span class="sgc-1">class</span> =<span class="sgc-2">"translations"</span>&gt;
                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  hello &lt;br /&gt;
                  hi &lt;br /&gt;
                  how are you? &lt;br /&gt;
                &lt;/div&gt;

              &lt;/div&gt;
        &lt;/div&gt;
        &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"card"</span>&gt;
          &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"english"</span>&gt;
            &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
              hello (interj., esp. on telephone)
            &lt;/div&gt;
          &lt;/div&gt;

              &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"pinyin"</span>&gt;

                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  wèi
                &lt;/div&gt;
              &lt;/div&gt;
              
              &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"traditional"</span>&gt;
                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  喂
                &lt;/div&gt;
              &lt;/div&gt;
              
              &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"simplified"</span>&gt;

                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  喂
                &lt;/div&gt;
              &lt;/div&gt;

              &lt;div <span class="sgc-1">class</span> =<span class="sgc-2">"translations"</span>&gt;
                &lt;div <span class="sgc-1">class</span>=<span class="sgc-2">"vcenter"</span>&gt;
                  hello (interj., esp. on telephone) &lt;br /&gt;
                  hey &lt;br /&gt;

                  to feed (sb or some animal) &lt;br /&gt;
                &lt;/div&gt;
              &lt;/div&gt;
        &lt;/div&gt;
    &lt;/p&gt;

    &lt;p <span class="sgc-1">class</span> =<span class="sgc-2">"return"</span>&gt;
      <span class="sgc-3">Press</span> &lt;<span class="sgc-3">Space</span>&gt; to <span class="sgc-1">continue</span>
        &lt;br/&gt;     
      &lt;a href=<span class="sgc-2">"http:/flashcards.html"</span>&gt; <span class="sgc-3">Return</span> to <span class="sgc-3">Flash</span> <span class="sgc-3">Cards</span> list&lt;/a&gt;
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;

</span></code></pre>

  <p>Copyright Jan Newmarch, jan@newmarch.name</p>

  <p>If you like this book, please contribute using Flattr <a class="FlattrButton sgc-8" href="http://jan.newmarch.name/go/index.html"></a><br />
  or donate using PayPal</p>

  <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
    <input name="cmd" type="hidden" value="_s-xclick" /> <input name="encrypted" type="hidden" value="-----BEGIN PKCS7-----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-----END PKCS7----- " /> <input alt="PayPal - The safer, easier way to pay online." border="0" name="submit" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/btn/btn_donateCC_LG.gif" type="image" /> <img alt="" border="0" height="1" src="https://www.paypalobjects.com/WEBSCR-640-20110401-1/en_AU/i/scr/pixel.gif" width="1" />
  </form>
</body>
</html>
